chaque requete a un proprio qui doit s'en occupé
une requete a
	- un proprio
	- un besoin (energie, soin, creation, etc...)
	- un fourniseur
	- une priorité (0 = ultra	urgent, infini = en dernier)
	optionel :
		- un modele
		- un lieu de rdv (x,y) (si besoin)

vie d'une requete :
	- lancement par le proprio
	- un fourniseur la prend en charge
	- le fourniseur ne peut subvenir a la requete et annule sa prise en charge.
	- le proprio n'a plus besoin de la requete et l'annule
	- la requete est validé. Elle disparait

gestion divine
	- gestion par type de peon
	- lancement de la gestion des peons même s'il n'existe pas
	- avantage
		- pas de problème de morts subite
		- ordre de gestion des peons stable voir fixe
	- inconvegnant
		- surconsomation de CPU a chaque tour
		- ne gère pas les peons qui ne sont pas dans les fichiers de config
		- récriture total des classes de gestion de peon (pas un mal en sois, juste long)

charger les types de peon
	certain type sont en rapports avec un objet (source, exit, etc...)
	certain type sont en rapport a une room (constructeur, etc...)
	certain type sont en rapport au nombre d'autre peon existant (transporteur, medecin, etc...)

définition d'un type :
	- le modele (qui pourra être modulaire au final (récolteur...))
	- définition du point de comparaison pour le ratio
	- ratio (exemple : 3 peon par source)

class peon extand creeps
	attributs
		plan de construction
		nom
	methode
		creer = requete
		faire_requete
		repondre_requete

requete de creation
	on boucle sur tout les peons, ceux qui n'existe pas lance une requete
	prio de la requete permet de savoir dans quel ordre
